#!/usr/bin/perl
##### ColourIdSort.pl ##########################################################
# Sorts JUCE ColourId values into general categories.                          #
#                                                                              #
#---- Description: ------------------------------------------------------------# 
#  A ColourId namespace file generated by ColorID_Namespace_Generator.pl       #
# should be provided as the input file. This script will read in all color     #
# IDs, and prompt the user to sort them into default UI element categories.    #
#                                                                              #
#  Once sorted, it will generate two strings defining C++ std::maps. The first #
# maps each category to the list of all associated color IDs, and the second   #
# maps each colorId to its default category value. These will be saved to disk #
# at the path provided as the output file.                                     #
#                                                                              #
#---- Usage: ------------------------------------------------------------------#
# ./ColourSort.pl [input file] [output file]                                   #
################################################################################

use strict;
use warnings;
use File::Slurp;
use List::Util qw(max);

if(!defined($ARGV[0]) || !defined($ARGV[1]))
{
    die "usage: ./ColourIdSort.pl [input file] [output file]\n";
}

# Lists all UI element categories
my @categories = 
(
	"windowBackground",
	"widgetBackground",
	"widgetOff",
	"widgetOn",
	"menuBackground",
	"outline",
	"focusedOutline",
	"textField",
	"text",
	"highlightedTextField",
	"highlightedText",
	"none"
);

my $idFile = read_file($ARGV[0]) or die "Couldn't read input file!\n";

# Read in all inner namespace enum values in the ColourIds Namespace.
my @enums = 
    $idFile =~ /
                    namespace \s+\w+\s+     #match all namespaces
                    {\s+
                        enum\s+
                        { 
                            .+?             #match all enum content 
                        };\s+
                    };
                /gsx;

# Store each ColorId enum value as a hash reference, mapping the namespace 
# identifier as "namespace" and the ColorID enum value's name as "color"
my @colourIds;
foreach my $enum(@enums)
{
	if($enum =~ /^namespace (\w+)/)
	{
		my $namespace = $1;
                # Capture enum values by finding each group of word characters
                # followed by whitespace and an equals sign.
		my @colors = ($enum =~ /(\w+)\s+=/g);
		foreach my $color(@colors)
		{
			push(@colourIds,
                                {
                                    "namespace"=>$namespace, 
                                    "color"=>$color
                                });
		}
	}
}
print("Found ".scalar @colourIds." colors in ".scalar @enums." classes\n");

# Sort IDs alphabetically by enum value name, and convert the list to
# "namespace::color" string values.
@colourIds = sort { $a->{"color"} cmp $b->{"color"}} @colourIds;
foreach my $i(0...(scalar @colourIds) - 1)
{
    $colourIds[$i] = $colourIds[$i]->{"namespace"}."::"
            .$colourIds[$i]->{"color"};
}

# For each category type $categories[$i], $sortedIds[$i] will contain an array
# reference holding all "namespace::color" strings generated from the values
# in @colourIds.
my @sortedIds;
foreach my $i(0...(scalar @categories) - 1)
{
	$sortedIds[$i]= [];
}

#Tracks the total number of colourIds sorted into categories
my $sorted = 0;

#Saves the last category choice selected with the prompt function.
my $lastEntry = "0";

##### prompt(colourId): ########################################################
#
# Prompts the user to select a UI Category for a specific colourId, repeating
# as necessary until either a valid category is selected, or the user enters 'q'
# to terminate the program.
#
# colourId:  The display name of a colourId, used to tell the user which ID
#            to select a category for.
#
# return:    The category index selected by the user.
################################################################################
sub prompt{
	my $id = shift;
	my $max = @colourIds;
	my $result = "";
	while(! $result =~ /[0-9]+/)
	{
		system("clear");
		print("Pick a UI category number.\n");
		my $numCategories = @categories;
		for(my $i = 0; $i < $numCategories; $i++)
		{
			print("$i: ".$categories[$i]."\n");
		}
		print("ID $sorted/$max: $id\n");
		print("Enter 0 - $numCategories,(Q)uit, or nothing to"
			." repeat[$lastEntry]:");
		$result = <STDIN>;
		if($result =~ /q/i)
		{
			die "exiting...";
		}
		if($result =~ /^\s*$/)
		{
			$result = $lastEntry."\n";
		}
	}
	$lastEntry = $result;
	$lastEntry =~ s/[^0-9]//g;
	return $result;
}

foreach my $idStr(@colourIds)
{
	$sorted++;
	my $selection = $sortedIds[prompt($idStr) ];
	push(@{$selection}, $idStr);
}

open(IDLIST,">",$ARGV[1]) or die "Couldn't open output file!\n";

my %colorCategories; #map each colorID to its UI category.

##### tabs(tabCount): ##########################################################
# Convert a tab count to a string containing that many tabs, where each tab is
# represented by four spaces.
################################################################################
sub tabs
{
    my $tabCount = shift;
    my $tabString = "";
    foreach my $i(0...$tabCount - 1)
    {
        $tabString = $tabString."    ";
    }   
    return $tabString;
}

# Map UI categories to all associated colorIDs, generating the colorCategories
# hash in the process.
print(IDLIST "std::map<ColourConfigFile::UICategory, Array<int>>\n".
        "ColourConfigFile::categoryIDs =\n{");
foreach my $i(0...(scalar @categories) - 1)
{
    my $tabCount = 1;
    if($i > 0)
    {
        print(IDLIST ",");
    }
    print(IDLIST "\n".tabs($tabCount)."{\n");
    $tabCount++;
    print(IDLIST tabs($tabCount)."ColourConfigFile::UICategory::"
            .$categories[$i].",\n");
    print(IDLIST tabs($tabCount)."{");
    $tabCount++;
    my @ids = sort @{$sortedIds[$i]};
    foreach my $idNum(0...(scalar @ids) - 1)
    {
        if($idNum > 0)
        {
            print(IDLIST ",");
        }
        print(IDLIST "\n".tabs($tabCount)."ColourIds::".$ids[$idNum]);
        $colorCategories{$ids[$idNum]} = $categories[$i];
    }
    $tabCount--;
    print(IDLIST "\n".tabs($tabCount)."}");
    $tabCount--;
    print(IDLIST "\n".tabs($tabCount)."}");
}
print(IDLIST "\n};\n");

#re-sort colourIds alphabetically by full name
@colourIds = sort @colourIds;
# Use the colorCategories hash to print the map of all ColorIds to UICategories
print(IDLIST "std::map<int, ColourConfigFile::UICategory>\n"
        ."ColourConfigFile::idCategories =\n{");
foreach my $i(0...(scalar @colourIds) - 1)
{
    if(defined($colorCategories{$colourIds[$i]}))
    {
        if($i > 0)
        {
            print(IDLIST ",");
        }
        my $line = "\n".tabs(1)
                ."{\n".tabs(2)
                ."ColourIds::".$colourIds[$i]
                .",\n".tabs(2)
                ."ColourConfigFile::UICategory::"
                .$colorCategories{$colourIds[$i]}."\n"
                .tabs(1)."}";
        print(IDLIST $line);  
    }
}
print(IDLIST "\n};");
close IDLIST;
